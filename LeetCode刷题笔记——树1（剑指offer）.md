# LeetCode刷题笔记——树(1)（剑指offer）

## 重建二叉树（20.12.8）

### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 ### 样例

输入：

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

结果：

```
    3
   / \
  9  20
    /  \
   15   7
```

### 思路

二叉树前序遍历结果：根节点----左子树（前序）----右子树（前序），中序遍历结果：左子树（中序）----根节点----右子树（中序）。由于二叉树是递归定义的，所以我们不难想到用递归的方法来解决这一问题。

所以我们只需要找到根节点，再分别找出左右子树的前序序列和中序序列即可。设前序序列为$$Preorder=\{P_0,P_1,\cdots ,P_{n-1}\}$$ ，中序序列为$$Inorder=\{I_0,I_1,\cdots,I_{n-1}\}$$。那么根据之前的分析，$$P_0$$是当前根节点，然后我们在中序序列中找到和$$P_0$$相等的节点，下标记为$$index$$。所以$$I_{index}$$就是中序序列的当前根节点，然后我们根据中序序列的性质可知左子树的中序序列为$$\{I_0,\cdots,I_{index-1}\}$$，右子树的中序序列为$$\{I_{index+1},\cdots,I_{n-1}\}$$。由于一棵树的前序序列和中序序列长度是一致的，再根据前序序列的性质我们可以根据子树中序序列的下标范围推出子树前序序列：左子树的前序序列为$$\{P_1,\cdots,P_{index}\}$$，右子树的前序序列为$$\{P_{index+1},\cdots,P_{n-1}\}$$。至此我们知道了如何得到左右子树的前中序序列，只需要递归的调用该函数即可。

### 代码实现（C++）

#### 序列分片

由于测试样例数据是由 vector<int> 方式传递的所以需要一种方式来实现向量的快速分片。这里使用迭代器（iterator）实现，对于vector的构造函数vector（iterator $$i1$$，iterator $$i2$$）会将$$i1$$指向的元素到$$i2$$指向元素之前的一个元素作为初始化参数。所以根据上述的子树序列范围，代码实现如下：

```C++
int size=preorder.size();

vector<int>leftp(preorder.begin()+1,preorder.begin()+index+1);
vector<int>lefti(inorder.begin(),inorder.begin()+index);
root->left=buildTree(leftp,lefti);
//构造左子树

vector<int>rightp(preorder.begin()+index+1,preorder.begin()+size);
vector<int>righti(inorder.begin()+index+1,inorder.begin()+size);
root->right=buildTree(rightp,righti);
//构造右子树
```



#### 边界条件

首先考虑输入：如果输入的vector为空，那么返回即可空指针即可。

再考虑vector构造函数参数的合法性：即第二个迭代器不能指向第一个迭代器指向值之前的值，也就是$$i2\geq i1$$。所以对于左子树必须满足：$$index \geq 0$$，对于右子树必须满足：$$index\leq size-1$$。由于$$index$$是中序序列的某个下标，所以肯定符合上述两个不等式。就不需要进行单独处理。



## 子树的结构（20.12.8）

### 题目描述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)。B是A的子结构， 即 A中有出现和B相同的结构和节点值。

### 样例

样例1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

样例2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 思路

根据题目的理解，树B如果是树A的子树，那么A至少存在一个节点$$Anode_i$$使得B是树$$Anode_i$$的子树且节点$$Anode_i$$是这个子树的跟，我们称之为同根子树。如果我们对于给定的两棵树可以判断是否为同根子树，那么对于整个问题，我们只需要判断

1. B是否为A的同根子树
2. B是否为A左子树的子树
3. B是否为A右子树的子树

而对于同根子树的判断，我们只需要判断两树根值是否相同，再递归的判断左右子树即可。**对于整个问题来说，其实就是对A树的前序遍历。**

#### 代码实现

##### 边界条件

在树相关问题中最关键的边界条件就是空指针。在前序遍历过程中，根据题目要求，任何一个树为空指针那么判断结果就是false。在同根子树判断时，B为空指针时就说明比较已经判断了B的一个叶子节点，那么就应该返回true；如果A为空指针就说明A已经没有子树结构了，但是这是B还不为空（否则在上一个条件就已经返回了），所以应该返回false；如果A根值和B值不相等，就应该返回false；最后上述条件都不满足时，继续递归判断AB的左右子树即可。





## 二叉树的镜像  （20.12.9）

### 题目描述

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

### 样例

```
输入：		4					输出：   4
   		/   \						/   \
  	   2     7					   7     2
	  / \   / \					  / \   / \
	 1   3 6   9				 9   6 3   1
```

### 思路

有关树的结构问题我们首先考虑递归解法，假设函数recursion可以求出一个子树的镜像，那么对于一个更大的树，我们只需要构造一个新的根节点使他等于输入树的根节点，然后令新树的左子树等于输入树右子树的镜像，新树的右子树等于输入树左子树镜像即可。



## 对称的二叉树 （20.12.9）

### 题目描述 

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

### 样例

```
输入： 1				输出：true
   	 / \
    2   2
   / \ / \
  3  4 4  3
```

### 思路

如果一颗二叉树是镜像的，那么他的左右子树肯定是镜像的，根据上一题的分析，两树AB是互为镜像的，那么A.left和B.right以及A.right和B.left都是互为镜像的，这时候只需要写一个递归的方法判断两树是否互为镜像即可。

### 实现

对于上述函数的实现，只需要判断好传入的AB是否为空指针以及相应的处理即可：

```C++
    bool subTreeSymmetric(TreeNode*A,TreeNode*B)
	{
        if(A==NULL)
        {
            if(B==NULL)return true;
            else return false;
        }
        if(B==NULL)return false;

        if(A->val!=B->val)return false;

        return  subTreeSymmetric(A->left,B->right)&&                         			subTreeSymmetric(A->right,B->left);

    }
```



## 二叉树中和为某一值的路径  （20.12.10）

###  题目描述

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

### 样例

```
输入：
			  5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
sum = 22
	
返回：
[
   [5,4,11,2],
   [5,8,4,5]
]
```

### 思路

在树的遍历过程中我们额外记录一下从根节点到当前节点的路径以及路径和，然后判断一下当前节点如果是根节点，那么比较路径和是否等于sum，如果是就将路径加入到rst中，如果不是，那就继续遍历。*【记录路径是树类题目中一个比较常见的需求】*

为了节省空间，我们用一个引用类型的容器来存储路径，这就意味着当我们结束访问一个节点的时候就要将该节点从路径中删除，其实这就是一个回溯过程。

### 实现

递归函数中首先要做到就是空指针判断，然后就是将节点加入路径，判断路径是否符合条件，再进行左右子树递归，最后从路径中删除节点：

```C++
void recursion(TreeNode*subTree,vector<int>&path,
vector<vector<int>>&rst,int target)
    {
        if(subTree==NULL) return;
        
        path.push_back(subTree->val);
        if(subTree->left==NULL&&subTree->right==NULL&&subTree->val==target)
        {
            rst.push_back(path);
        }
            
        if(subTree->left!=NULL)    
            recursion(subTree->left,path,rst,target-subTree->val);
            
        if(subTree->right!=NULL)
            recursion(subTree->right,path,rst,target-subTree->val);
                
        path.erase(path.end()-1);
        return;
        
    }
```



##  平衡二叉树 （20.12.11）

### 题目描述

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

### 样例

```
输入： 	3			返回：true
   		 / \
        9  20
      /  \
     15   7
```

### 思路

根据树的递归定义，如果一颗树是平衡二叉树的话，那么这棵树满足

- 左右子树是平衡二叉树
- 左右子树高度差不超过1

那么我们就可以设计一个函数来求树的高度，当这棵树左右子树高度差大于1时返回-1，这样同时满足了求高度和判断子树为平衡树这两个功能

### 代码

```C++
int recursion(TreeNode *subTree)
    {
        if(subTree!=NULL)
        {
            int depL=recursion(subTree->left);
            int depR=recursion(subTree->right);
            if(depL==-1||depR==-1)
                return -1;
            else if(abs(depL-depR)>=2)
                return -1;
            else
                return max(depR,depL)+1;
        }
        return 0;
    }
```



## 二叉搜索树最近的公共祖先 （20.12.12）

### 题目描述

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大。

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

### 样例

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

### 思路

假设根节点到P，Q的路径分别为$$\{R,S_1,S_2,\cdots,S_n,P_1,\cdots,P_{x_1}，P\}$$，$$\{R,S_1,S_2,\cdots,S_n,Q_1,\cdots,Q_{x_2}，Q\}$$，其中S表示相同路径上的节点，那么根据二叉树的性质P,Q不可能同时大于或小于$$S_n$$，这样$$S_n$$就不会是相同路径上最后一个节点，反之我们可以退出$$S_n$$之前的所有节点都是同时大于或小于P，Q的，所以我们只需要找出最后一个同时大于或小于P，Q的节点即可。

### 实现

由于题目给出了p，q一定存在所以不需要判断空指针的情况，如果没有这条说明需要考虑空指针



## 二叉搜索树最近的公共祖先 （20.12.12）

### 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大。

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

### 样例

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

### 思路

和上一题相比较而言，二叉树不具有节点大小之间的关系，只能分别找出P,Q的路径再返回，于是我们实际一个函数寻找某个节点的path。在这一过程在，循环是比递归更好的实现，因为在递归实现时，即使我们已经找到了一个节点，但是此时很可能还处于递归栈中，于是我们需要进一步判断是否需要把当前节点弹出路径数组。循环则不存在这个问题，找到目标节点直接返回即可。最后对于两个路径数组，我们只需要遍历找出最后一个相同的即可。

### 实现

递归实现寻找路径：

```C++
bool findNode(TreeNode*subRoot,vector<TreeNode*>&path,int key)
    {
        if(subRoot==NULL)return false;  //空节点直接返回
       

        path.push_back(subRoot);
        if(subRoot->val==key)return true;  //找到目标节点

        bool findFlag=false;
        findFlag|=findNode(subRoot->left,path,key);
        findFlag|=findNode(subRoot->right,path,key);
    	
    	//分别在左右子树寻找

        if(findFlag) return true;  //如果在子树中找到直接返回
        else
        {	
            path.pop_back();	   //反之将当前节点弹出栈再返回
            return false;
        }
    }
```

循环实现寻找路径：

//TODO