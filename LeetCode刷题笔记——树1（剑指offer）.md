# LeetCode刷题笔记——树(1)（剑指offer）

## 重建二叉树（20.12.8）

### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 ### 样例

输入：

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

结果：

```
    3
   / \
  9  20
    /  \
   15   7
```

### 思路

二叉树前序遍历结果：根节点----左子树（前序）----右子树（前序），中序遍历结果：左子树（中序）----根节点----右子树（中序）。由于二叉树是递归定义的，所以我们不难想到用递归的方法来解决这一问题。

所以我们只需要找到根节点，再分别找出左右子树的前序序列和中序序列即可。设前序序列为$$Preorder=\{P_0,P_1,\cdots ,P_{n-1}\}$$ ，中序序列为$$Inorder=\{I_0,I_1,\cdots,I_{n-1}\}$$。那么根据之前的分析，$$P_0$$是当前根节点，然后我们在中序序列中找到和$$P_0$$相等的节点，下标记为$$index$$。所以$$I_{index}$$就是中序序列的当前根节点，然后我们根据中序序列的性质可知左子树的中序序列为$$\{I_0,\cdots,I_{index-1}\}$$，右子树的中序序列为$$\{I_{index+1},\cdots,I_{n-1}\}$$。由于一棵树的前序序列和中序序列长度是一致的，再根据前序序列的性质我们可以根据子树中序序列的下标范围推出子树前序序列：左子树的前序序列为$$\{P_1,\cdots,P_{index}\}$$，右子树的前序序列为$$\{P_{index+1},\cdots,P_{n-1}\}$$。至此我们知道了如何得到左右子树的前中序序列，只需要递归的调用该函数即可。

### 代码实现（C++）

#### 序列分片

由于测试样例数据是由 vector<int> 方式传递的所以需要一种方式来实现向量的快速分片。这里使用迭代器（iterator）实现，对于vector的构造函数vector（iterator $$i1$$，iterator $$i2$$）会将$$i1$$指向的元素到$$i2$$指向元素之前的一个元素作为初始化参数。所以根据上述的子树序列范围，代码实现如下：

```C++
int size=preorder.size();

vector<int>leftp(preorder.begin()+1,preorder.begin()+index+1);
vector<int>lefti(inorder.begin(),inorder.begin()+index);
root->left=buildTree(leftp,lefti);
//构造左子树

vector<int>rightp(preorder.begin()+index+1,preorder.begin()+size);
vector<int>righti(inorder.begin()+index+1,inorder.begin()+size);
root->right=buildTree(rightp,righti);
//构造右子树
```



#### 边界条件

首先考虑输入：如果输入的vector为空，那么返回即可空指针即可。

再考虑vector构造函数参数的合法性：即第二个迭代器不能指向第一个迭代器指向值之前的值，也就是$$i2\geq i1$$。所以对于左子树必须满足：$$index \geq 0$$，对于右子树必须满足：$$index\leq size-1$$。由于$$index$$是中序序列的某个下标，所以肯定符合上述两个不等式。就不需要进行单独处理。



## 子树的结构（20.12.8）

### 题目描述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)。B是A的子结构， 即 A中有出现和B相同的结构和节点值。

### 样例

样例1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

样例2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 思路

根据题目的理解，树B如果是树A的子树，那么A至少存在一个节点$$Anode_i$$使得B是树$$Anode_i$$的子树且节点$$Anode_i$$是这个子树的跟，我们称之为同根子树。如果我们对于给定的两棵树可以判断是否为同根子树，那么对于整个问题，我们只需要判断

1. B是否为A的同根子树
2. B是否为A左子树的子树
3. B是否为A右子树的子树

而对于同根子树的判断，我们只需要判断两树根值是否相同，再递归的判断左右子树即可。**对于整个问题来说，其实就是对A树的前序遍历。**

#### 代码实现

##### 边界条件

在树相关问题中最关键的边界条件就是空指针。在前序遍历过程中，根据题目要求，任何一个树为空指针那么判断结果就是false。在同根子树判断时，B为空指针时就说明比较已经判断了B的一个叶子节点，那么就应该返回true；如果A为空指针就说明A已经没有子树结构了，但是这是B还不为空（否则在上一个条件就已经返回了），所以应该返回false；如果A根值和B值不相等，就应该返回false；最后上述条件都不满足时，继续递归判断AB的左右子树即可。